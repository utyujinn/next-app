---
title: DMAとbitplaneについて
date: 2025-08-05
tags: 
  - snes
  - 65c816
  - DMA
---

## DMA

### なぜ必要？
DMAとは、direct memory accesの略で、CPUから独立してデータを送信する機能のことである。NESにはなかったこの機能がSNESになって現れたのには、理由がある。メモリ量の大幅な上昇だ。NESのメモリは2KBだったのに対し、SNESのメモリは128KBと、64倍となっている。しかし、CPUの速度はわずか二倍程度だ。このため、これをボトルネックとしないためにもDMAを実装する必要があった。

### どう動く？
SNESには、複数のメモリが分かれている。これらをつなぐバスが3つある。
- Bus A(アドレスバス): 24bit長。CPU,カートリッジ(ROM+SRAM),メインメモリ(WRAM)をつなぐ。
- Bus B(アドレスバス): 8bit長。メインバスアドレススペース(ハードウェアレジスタ)にある特別なアドレスと介してAPUとPPUを接続する。
- 8-bit長のデータバス。A,Bバスからコントロールされ、いろいろなところにデータを送る。DMAを行っているときにはCPUによってブロックされる。
CPUには、DMAコントローラがあり、8このDMAチャンネルがある。0が実行に置いて優先度が高く、7が低い。

DMAをしている間、"burst"という機能でCPUは動作を停止します。これは、転送の際にCPUとDMAコントローラはどちらもシステムバスを使って通信するため、干渉が起きてしまうためだ。

DMAに命令できるレジスタは4200-4400に存在する。

### HDMA
H-Blankという、走査線が右から左に戻るまでの短い時間で1~4byteのデータを送るDMAをHDMAという。

### サンプルコード
参考からほぼコピペ。Aレジスタのサイズを一部変更している。
```DMA.asm
 ;macro for loading palette data into the CGRAM
 ;only use if SIZE is less than 256 bytes
 ;syntax SetPalette LABEL CGRAM_ADDRESS SIZE
 .macro LoadPalette
 pha
 php

 rep	#$20		; 16bit A
 lda	#\3
 sta	$4305		; # of bytes to be copied
 lda	#\1		; offset of data into 4302, 4303
 sta	$4302
 sep	#$20		; 8bit A

 lda	#:\1		; bank address of data in memory(ROM)
 sta	$4304
 lda	#\2
 sta	$2121		; address of CGRAM to start copying graphics to

 stz	$4300		; 0= 1 byte increment (not a word!)
 lda	#$22
 sta	$4301		; destination 21xx   this is 2122 (CGRAM Gate)

 lda	#$01		; turn on bit 1 (corresponds to channel 0) of DMA channel reg.
 sta	$420b		;   to enable transfer

 plp
 pla
 .endm

 ;macro for loading graphics data into the VRAM
 ;only use if SIZE is less than 256 bytes
 ;syntax LoadVRAM LABEL  VRAM_ADDRESS  SIZE
 .macro LoadVRAM

 pha			; save the current accumulator, Y index and status registers for the time the function is executed.
 phy
 php
 
 rep	#$20		; set the accumulator (A) register into 16 bit mode
 sep	#$10		; set the index (X and Y) register into 8 bit mode

 ldy	#$80		;  we will try to write 128 ($80) bytes in one row ...
 sty	$2115		; ... and we will let the PPU let this know.

 lda	#\2		; the controller will get the hardware register ($2118) as location to where to write the data.
 sta	$2116		; but we still need to specify WHERE in VRAM we want to write the data - what we are doing right now.

 lda	#\3		; number of bytes to be sent from the controller.
 sta	$4305

 lda	#\1		; from where the data is supposed to be loaded from		
 sta	$4302

 sep #$20
 
 ldy	#:\1		; from which bank the data is supposed to be loaded from
 sty	$4304

 ldy	#$01		; set the mode on how the channel is supposed to do it's work. 1= word increment
 sty	$4300

 ldy	#$18		; remember that I wrote "the controller will get the hardware register"? This is it. 2118 is the VRAM gate.
 sty	$4301
 
 ldy	#$01		; turn on bit 1 (channel 0) of DMA - that is, start rollin'
 sty	$420b

  
 plp			; Restore the state of all registers before leaving the function.
 ply
 pla
 .endm

```

### ビットプレーン
ビットプレーンとは、ある画像を表すときに、例えば4bit分の深みがあるとして、それぞれのプレーン(平面)ごとに値を表すという方式である。SNESではこの方式が採用されている。具体例を見たほうが早いだろう。次のような8x8のタイルを考える。
```
A A A A A A A A
A 5 5 5 5 5 5 A
A 5 5 5 5 5 5 A
A 5 5 5 5 5 5 A
A 5 5 5 5 5 5 A
A 5 5 5 5 5 5 A
A 5 5 5 5 5 5 A
A A A A A A A A
```
それぞれの値に`&0001`すると、
```bp1
0 0 0 0 0 0 0 0
0 1 1 1 1 1 1 0
0 1 1 1 1 1 1 0
0 1 1 1 1 1 1 0
0 1 1 1 1 1 1 0
0 1 1 1 1 1 1 0
0 1 1 1 1 1 1 0
0 0 0 0 0 0 0 0
```
`&0010`すると、
```bp2
1 1 1 1 1 1 1 1
1 0 0 0 0 0 0 1
1 0 0 0 0 0 0 1
1 0 0 0 0 0 0 1
1 0 0 0 0 0 0 1
1 0 0 0 0 0 0 1
1 0 0 0 0 0 0 1
1 1 1 1 1 1 1 1
```
`&0100`すると、
```bp3
1 1 1 1 1 1 1 1
1 0 0 0 0 0 0 1
1 0 0 0 0 0 0 1
1 0 0 0 0 0 0 1
1 0 0 0 0 0 0 1
1 0 0 0 0 0 0 1
1 0 0 0 0 0 0 1
1 1 1 1 1 1 1 1
```
それぞれの値に`&1000`すると、
```bp4
0 0 0 0 0 0 0 0
0 1 1 1 1 1 1 0
0 1 1 1 1 1 1 0
0 1 1 1 1 1 1 0
0 1 1 1 1 1 1 0
0 1 1 1 1 1 1 0
0 1 1 1 1 1 1 0
0 0 0 0 0 0 0 0
```
となる。
これを次のフォーマットで16進数に直すと、(rはrow、bpはbitplane)
```
  [r0, bp1], [r0, bp2], [r1, bp1], [r1, bp2], [r2, bp1], [r2, bp2], [r3, bp1], [r3, bp2]
  [r4, bp1], [r4, bp2], [r5, bp1], [r5, bp2], [r6, bp1], [r6, bp2], [r7, bp1], [r7, bp2]
  [r0, bp3], [r0, bp4], [r1, bp3], [r1, bp4], [r2, bp3], [r2, bp4], [r3, bp3], [r3, bp4]
  [r4, bp3], [r4, bp4], [r5, bp3], [r5, bp4], [r6, bp3], [r6, bp4], [r7, bp3], [r7, bp4]
  [r0, bp5], [r0, bp6], [r1, bp5], [r1, bp6], [r2, bp5], [r2, bp6], [r3, bp5], [r3, bp6]
  [r4, bp5], [r4, bp6], [r5, bp5], [r5, bp6], [r6, bp5], [r6, bp6], [r7, bp5], [r7, bp6]
  [r0, bp7], [r0, bp8], [r1, bp7], [r1, bp8], [r2, bp7], [r2, bp8], [r3, bp7], [r3, bp8]
  [r4, bp7], [r4, bp8], [r5, bp7], [r5, bp8], [r6, bp7], [r6, bp8], [r7, bp7], [r7, bp8]
```
このようになる。
```
$FF $00 $7E $81 $7E $81 $7E $81 $7E $81 $7E $81 $7E $81 $FF $00
$FF $00 $7E $81 $7E $81 $7E $81 $7E $81 $7E $81 $7E $81 $FF $00
```
よって、これを書き込むことで無事に周りに枠があるタイルを作成することができる。
[https://x.com/nktssbat/status/1952593695171358854](https://x.com/nktssbat/status/1952593695171358854)

## 参考
[DMA tutorial](https://en.wikibooks.org/wiki/Super_NES_Programming/DMA_tutorial)
[Console Graphics Document](https://mrclick.zophar.net/TilEd/download/consolegfx.txt)